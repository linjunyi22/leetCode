package in

// 169. 多数元素
// 难度：简单
// 链接：https://leetcode.cn/problems/majority-element/
// 解题思路：
// 方法一：哈希表统计法
// 1. 多数元素的定义：在数组中出现次数大于 ⌊n/2⌋ 的元素
// 2. 使用哈希表统计法：
//   - 遍历数组，用map记录每个元素出现的次数
//   - 再次遍历map，找到出现次数超过n/2的元素
//
// 3. 时间复杂度：O(n)，需要遍历数组一次，遍历map一次
// 4. 空间复杂度：O(n)，需要额外的map存储空间
//
// 方法二：Boyer-Moore 投票算法
// 1. 通俗理解：
//   - 想象一个投票场景，候选人 candidate 需要超过半数票才能当选
//   - 支持票相当于 +1，反对票相当于 -1
//   - 当支持票和反对票抵消后（count = 0），现任候选人已经无法获胜，需要换新的候选人
//
// 2. 为什么这样做是对的？打个比方：
//   - 假设数组是：[2,2,1,1,2,2,1,2,2]，众数是2
//   - 第一轮：2(+1), 2(+2), 1(+1), 1(0) -> 前四个数两两抵消
//   - 继续：  2(+1), 2(+2), 1(+1), 2(+2), 2(+3) -> 最后2胜出
//   - 因为众数超过半数，即使最坏情况下它的票被其他数抵消，最后阶段也一定会胜出
//
// 3. 时间复杂度：O(n)，相当于一次投票统计
// 4. 空间复杂度：O(1)，只需要记录当前候选人和他的票数

// 方法一：哈希表统计法
func majorityElement(nums []int) int {
	// 创建哈希表用于统计每个元素出现的次数
	m := make(map[int]int)

	// 第一次遍历：统计每个元素出现的次数
	for _, v := range nums {
		_, exist := m[v]
		if exist {
			m[v]++
		} else {
			m[v] = 1
		}
	}

	// 计算阈值：数组长度的一半
	limit := len(nums) / 2

	// 第二次遍历：找出出现次数超过阈值的元素
	for k, v := range m {
		if v > limit {
			return k
		}
	}

	// 根据题目描述，一定存在多数元素，这行代码实际上不会执行
	return nums[0]
}

// 方法二：Boyer-Moore 投票算法
func majorityElementMoore(nums []int) int {
	candidate := 0 // 候选众数
	count := 0     // 计数器

	// 遍历数组进行投票
	for _, v := range nums {
		if count == 0 {
			// 当计数器为0时，选择当前数作为候选众数
			candidate = v
			count++
		} else if v == candidate {
			// 当前数和候选众数相同时，计数器加1
			count++
		} else {
			// 当前数和候选众数不同时，计数器减1
			count--
		}
	}

	// 由于题目保证一定存在众数，因此候选众数就是答案
	return candidate
}
